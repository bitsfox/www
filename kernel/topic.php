<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<?php
echo "<pre>";
echo "
继续练习引导和启动模式
在head加载了以后，如果使用32位编程则在未进入保护模式时很难避免错误的发生，看来加入.code16并不像
0.11书中说的那样简单，只是将mov之类的指令加上w限制。

--------------problem------------
问题1：在加入.code16后编译的文件和使用宽度限制符movw编译的文件确实有差异，稍后研究吧。
现在解决方法是将所有进入保护模式前的代码都放在boot文件中，一个扇区的字节不够，可以顺序放入第二扇区，
一并将其读入执行。
连续扇区的代码测试成功，只要指定了第二扇区的加载位置即可，即加载到：0x7c00:0x200(512)处，然后跳转至
该位置继续执行即可.这样做的好处是，我可以在加载gdt\idt进入到保护模式之前使用一个文件用.code16完成所
有的引导和初始化代码。
问题2：加载了head代码后如果代码段选择符依然使用原来代码的0x7c0所在的段时，会出现代码可以执行，
但是数据访问错误，表现在使用lss加载ss/sp时出现错误以及显示信息获取错误。这个问题可以通过指定head
加载处地址作为新的代码段加入到gdt既能解决。但是为何使用原有段＋偏移（通过Ttext 5120指定）就不成功
呢？而且该位置的代码可以正常运行，数据加载不了（都在代码段中）－－恍然大悟，这可能与保护模式下代码
段的特性决定的，这也是为何反汇编时数据信息依然反汇编成了代码的原因吧。测试下。
测试结果：
第一：在使用ld链接时参数 -Ttext 或者 -Tdata后面跟着的地址是16进制的，也即：-Ttext 5120
并非我预期的10个扇区的位置，而是0x5120,相去甚远了，再者，如果仅仅指定了text段的加载位置，不指定data
段的话，data的默认加载位置并非想象的与text直接相连，通过查看bochs的各运行时寄存器的情况，也确实如此，
这种不确定性直接导致了数据定位的错误。才出现了代码正常运行，而数据显示不出来的问题。
第二：关于程序编译链接时设计的加载地址和设定读取磁盘数据加载至内存地址的一致性问题，就目前测试的情况
来看这个问题应该不会影响到加载程序的运行，只要设计好代码段的基地址就可以使程序正常执行，在我的测试中
head进程是在boot引导完成，并设置好gdt\idt再跳转至保护模式后，通过jmp跳转到head的加载位置开始执行的，
一般情况下，head的加载地址应该与head程序链接时设计的加载地址一致，我是将加载地址设计为0x1400（5120，10
个扇区位置之后，前10个为boot所用）如果不进行初始代码的移动的话，head加载进内存的地址为：0x7c00+0x1400
此时只要将代码段描述符中段基地址设计为0x7c00，然后jmp $0x8,$0x1400即可转入head进程的执行，而此时的加载
位置正好与链接head时设定的代码入口点一致，将能保证后续代码的正确转移执行。但是如果在链接时不指定入口地
址为0x1400的话，如指定为0,由boot跳转来后依然能正确执行，因为我们可以设计这时的段基地址为：0x7c00+0x1400
而在我的测试中，我并没有修改段基地址，依然使用的0x7c00，跳转到加载的位置后仍然能够正常执行，但是这时的加
载地址和设计的入口地址明显不一致了，由于head使用了32位的汇编设计，在剔除了pdr,comment,note等调试、链接信
息后不能使用objdump来查看反汇编信息了，
第三：在第一中提到的data段的加载位置不确定的问题也弄清楚了，这个问题的产生是因为源代码的编写是否是将.data
和.text段的定义伪指令放在一起，也就是是否所有的指令代码和数据代码都在一个作用域内，看来对.data和.text的定位
不仅能直接影响到org的定位，还影响到编译后程序的大小，实例如下：
代码形式1：
.data
.text
	....
代码形式2：
.text
.data
	....
代码形式3：
.text
	....
.data
	....
对于这三种情况的定义，在编译链接后，可以通过objdump -x来查看程序的各类信息：
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08049054

Program Header:
    LOAD off    0x00000000 vaddr 0x08049000 paddr 0x08049000 align 2**12
         filesz 0x00000254 memsz 0x00000254 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000200  08049054  08049054  00000054  2**2
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
08049054 l    d  .data  00000000 .data
08049089 l       .data  00000000 disp
0000000c l       *ABS*  00000000 len
08049104 l       .data  00000000 msg
08049054 g       .data  00000000 _start
08049254 g       *ABS*  00000000 __bss_start
08049254 g       *ABS*  00000000 _edata
08049254 g       *ABS*  00000000 _end
这是形式2的信息，形式1的信息和他几乎一致，就是将Section的Name换成了.text
也就是这两种形式的写法，其代码段和数据段的作用域完全一致，因此，在程序的编译、链接
过程中只需定义一个Section.
而形式3的信息则是:
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08048074

Program Header:
    LOAD off    0x00000000 vaddr 0x08048000 paddr 0x08048000 align 2**12
         filesz 0x000000c0 memsz 0x000000c0 flags r-x
    LOAD off    0x000000c0 vaddr 0x080490c0 paddr 0x080490c0 align 2**12
         filesz 0x00000200 memsz 0x00000200 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000004c  08048074  08048074  00000074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000200  080490c0  080490c0  000000c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
08048074 l    d  .text  00000000 .text
080490c0 l    d  .data  00000000 .data
080480a9 l       .text  00000000 disp
0000000c l       *ABS*  00000000 len
08049124 l       .data  00000000 msg
08048074 g       .text  00000000 _start
080492c0 g       *ABS*  00000000 __bss_start
080492c0 g       *ABS*  00000000 _edata
080492c0 g       *ABS*  00000000 _end
哈哈，由于这种定义方法代码段和数据段的作用域不同（指令代码不在.data中）所以，出现了
两个Section,而这两个段的定位地址并不相同，这时，如果.org在数据段作用域内，
则他的定位就是以.data的基地址开始计算的偏移，反之将以.text的基地址作为偏移计算。
Ttext定位测试:
通过这个程序的测试，更加清楚了程序加载后重定位信息的调整。实际上所有的标号在编译后都代表着一个段内的偏移，但是这个偏移
已经被编译链接程序硬编译进了程序的二进制文件中，当一个程序由系统加载时，系统会根据这些重定位信息在往内存的加载过程中依照
重定位信息或者修改重定位信息然后加载，这样在执行过程中就不会出现问题了，但是如果仅是将程序从磁盘读出到内存的某一位置，则
不涉及重定位的代码或指令可以顺利执行，但是所有涉及重定位的代码指令则不能正常执行了。因此，对于手动加载的程序必须依据加载
到的内存位置，在确定了段基地址后还要调整重定位项的数值！
测试idt的建立和使用
测试成功，需要注意的是：在设置idt的描述符时，指定的段选择符是中断函数所在的段，并且是可执行段
a02测试时，使用call时需注意：
1、必须要设置好堆栈。
2、在函数中使用堆栈操作时记住第一个pop出来的是系统自动压入堆栈的返回指针，需好存和恢复。
3、在测试局部标号0－9的使用，在不同的函数中使用同一数字标号没有岐义。
尼玛，代码的一丝错误简直就是逆天，一个磁盘读取的错误，将16进制误写成8进制。害我浪费了宝贵的一个晚上！
整数乘法的运算，如果使用mull的话，低32位在eax中，高32位在edx中。
-----------------------2014-08-18	关于重定位的补充-------------------------------------
在16位代码完成初始化，准备跳转进入32位模式时，有两种定位方式：
一、安全的定位方式：
就是将32位代码开始执行的地址设为新的段地址，加入到gdt表中。例如16位的初始化代码都在0x7c0：0000开始的第一个读入扇区内完成了，
现在将第二扇区的数据依次读入到0x7c0:0x200开始的地址并跳转至该处执行。而第二扇区就已经为32位代码了，此时可以将0x7c0:0x200设为
新的段基地址并加入到gdt中：.word 2,0x7e00,0x9a00,0x00c0。然后在加载了cr0后直接跳转至jmp $8,$0(假设该段选择符为8,偏移则为0).
这种做法的好处是在新读入的扇区数据中如果有新的数据，则可以正确的访问代码和数据。而无需考虑数据的重定位。
二、带偏移的定位方法：
这种方法与方法基本相似，不同的就是在构造32位代码段时不加入0x200的便宜，仍然使用一开始的0x7c0来构造，此时的段描述符为：
.word 2,0x7c00,0x9a00,0x00c0。由于这里没有加入0x200的便宜所以在跳转时要使用：jmp $8,$0x200(仍假设该段选择符为8)，这种写法如果
不再makefile文件中进行修改，跳转后的代码可以执行，但是数据访问可能出错。错误在于对数据的定位不对，为可测试，可以在代码中取得了
数据地之后再人为的加上一个偏移（人为的重定位，呵呵）这个偏移就是0x200! 因此，如果非要使用这种带偏移的定位，就必须在makefile文
件中做相应的修正，修正的方法又有两种：
1、如果在32位的源代码中是如下定义的：
.data
.text
则需要在makefile文件中对head文件的text段指定偏移： -Ttext 200
2、如果在32位的源代码中是如下定义的：
.text
.data
则需要在makefile中对head文件的data段指定偏移： -Tdata 200
如果在后面的代码中还有org定位的话，则第一种写法的作用域为data，此时org的定位是以data的偏移开始计算便宜的，第二种反之。

</pre>";
?>
